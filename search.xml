<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[制作文章词云]]></title>
    <url>%2F2017%2F12%2F15%2F%E5%88%B6%E4%BD%9C%E6%96%87%E7%AB%A0%E8%AF%8D%E4%BA%91%2F</url>
    <content type="text"><![CDATA[惯例，首先po上需要用到的工具的github链接吧： word_cloud介绍：A little word cloud generator in Python. Read more about it on the blog post or the website. The code is Python 2, but Python 3 compatible. jieba介绍：“结巴”中文分词：做最好的 Python 中文分词组件 代码展示人生苦短，先po代码！ 1234567891011121314151617181920212223242526272829303132333435363738394041# encoding=utf-8import reimport matplotlib.pyplot as pltfrom scipy.misc import imreadimport jieba.analysefrom wordcloud import WordCloud# 读入背景图片bg_pic = imread('mask.jpg')# 读取一个txt文件blog_path = r'../_posts/添加一个萌物.md' # 这里需要注意，要填入你自己对应博文的路径text_source = ''with open(blog_path, 'r', encoding='utf8') as f: text_source = f.read()word_freq = dict(jieba.analyse.extract_tags(text_source, topK=100, withWeight=True))# 这里是计算词语的出现频率的，后面会讲解一下参数wc = WordCloud( background_color='black', # 背景底色 mask=bg_pic, # 设置背景图 max_words=2000, # 设置最大显示的字数 font_path=r"C:\Windows\Fonts\AdobeHeitiStd-Regular.otf", # 设置中文字体，使得词云可以显示（词云默认字体是“DroidSansMono.ttf字体库”，不支持中文） max_font_size=200, # 设置字体最大值 random_state=50, # 设置有多少种随机生成状态，即有多少种配色方案)myword = wc.generate_from_frequencies(word_freq) #生成词云#展示词云图# plt.imshow(myword,interpolation='bilinear')# plt.axis("off")# plt.show()# 提取文件名pattern = re.compile(r'(\w+).md')out_img = re.search(pattern, blog_path).group(1)# 导出图片wc.to_file('&#123;&#125;.jpg'.format(out_img)) 代码讲解分两个部分： jieba：先看这段代码：1word_freq = dict(jieba.analyse.extract_tags(text_source, topK=100, withWeight=True)) 重点在jieba.analyse.extract_tags这个方法，里面有3个参数： text_source：原始博文的字符数据 topK：这个指的是出现最多的100个关键字，你可以调节这个数值 withWeight：这个是让数据返回时带上对应的频率值，也是这个代码中的一个关键点。 由于返回的数据是一个list，而词云的方法generate_from_frequencies接收的是一个dict，所以最后把它转化为一个字典。 WordCloud：这里我们只要注意WordCloud这个类初始化时要填入的参数：123456789wc = WordCloud( background_color='black', # 背景底色 mask=bg_pic, # 设置背景图 max_words=2000, # 设置最大显示的字数 font_path=r"C:\Windows\Fonts\AdobeHeitiStd-Regular.otf", # 设置中文字体，使得词云可以显示（词云默认字体是“DroidSansMono.ttf字体库”，不支持中文） max_font_size=200, # 设置字体最大值 random_state=50, # 设置有多少种随机生成状态，即有多少种配色方案) 每个参数后面都加上了注释，使用技巧上是，可以修改background_color，max_font_size，random_state这几个参数来调整图片显示的效果。 font_path这里我用的是我电脑上的字体路径 bg_pic这里我是使用了from scipy.misc import imreadscip中的imread方法，把图片以数据的形式读入，这样就可以把要展示的文字以图片轮廓的形式展现出来。 输出/展示1234567891011#展示词云图# plt.imshow(myword,interpolation='bilinear')# plt.axis("off")# plt.show()# 提取文件名pattern = re.compile(r'(\w+).md')out_img = re.search(pattern, blog_path).group(1)# 导出图片wc.to_file('&#123;&#125;.jpg'.format(out_img)) 我们可以展示词云，也可以导出到文件，中间我还用正则把博文的文件名提取出来作为词云图的文件名。 最后，一张自定义关于博文的词云图就生成在了代码的本地目录了。 词云图嵌入到博文中查看了Next的官网，看到了一个内置标签，找到突破容器宽度限制的图片这个标签的使用123456789&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class="full-image" 是必须的 --&gt;&lt;img src="/image-url" class="full-image" /&gt;&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% fullimage /image-url, alt, title %&#125;&lt;!-- 别名 --&gt;&#123;% fi /image-url, alt, title %&#125; 使用以下：1&#123;% fi /image-url, alt, title %&#125; 只要设置/image-url改为图片的路径。我的所有图片放到了Hexo\source\uploads这个文件夹内的。而Next的主题是有把uploads这个文件路径放到环境变量中的只要写如：/uploads/&lt;filename&gt;.jpg路径就可以了。 最后，一幅自定义的词云图就可以展示在你的博客里咯，这个技能你get√到了吗？ 赶紧用起来吧！]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Next</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[添加gitalk模块]]></title>
    <url>%2F2017%2F12%2F12%2F%E6%B7%BB%E5%8A%A0gitalk%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[惯例，首先进入作者的GitHub，看看使用方法。甩个链接：gitalk作者对于gitalk的定义是：Gitalk 是一个基于 Github Issue 和 Preact 开发的评论插件。 1.安装安装方式有2种： 1. 直接引入 2. npm安装 而我选择的是第一种 我们先来找到Hexo\themes\next\layout\_third-party\comments这个目录下，新建一个叫gitalk.swig的文件，里面写入下列代码：1234567891011121314151617&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125; &lt;link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"&gt; &lt;script src="https://unpkg.com/gitalk/dist/gitalk.min.js"&gt;&lt;/script&gt; //这两句是调用作者的css和js文件 &lt;script type="text/javascript"&gt; var gitalk = new Gitalk(&#123; //这里面的参数我们会在另一个文件中配置 clientID: '&#123;&#123;theme.gitalk.clientID&#125;&#125;', clientSecret: '&#123;&#123;theme.gitalk.clientSecret&#125;&#125;', repo: '&#123;&#123;theme.gitalk.repo&#125;&#125;', owner: '&#123;&#123;theme.gitalk.owner&#125;&#125;', admin: '&#123;&#123;theme.gitalk.admin&#125;&#125;', id: location.pathname, distractionFreeMode: '&#123;&#123;theme.gitalk.distractionFreeMode&#125;&#125;', &#125;) gitalk.render('gitalk-container') &lt;/script&gt;&#123;% endif %&#125; 同目录下的index.swig文件中，添加以下代码：1&#123;% include 'gitalk.swig' %&#125; 目的是使主页面包含上面新建的文件 2.配置我们找到主题配置文件_config.yml，找到下列这段代码：123456789# Gitalkgitalk: enable: true clientID: 'Github Application Client ID' clientSecret: 'Github Application Client Secret' repo: 'Github repo' //你网站的仓库名 owner: 'Github repo owner' //你的GitHub用户名 admin: ['Github repo owner and collaborators, only these guys can initialize github issues'] //同上 distractionFreeMode: true //这里指的是类似Facebook评论的遮罩效果 这里的重点是，需要在GitHub里申请applications的OAuth权限：地址这里申请后把Client ID、Client Secret的数据填入到上面clientID和clientSecret里就可以了。 3.生效最后找到\Hexo\themes\next\layout\_partials文件夹的comments.swig文件：这是评论模块的配置文件。在倒数第二层的if-else判断里加入：12&#123;% elseif theme.gitalk.enable %&#125; &lt;div id="gitalk-container"&gt;&lt;/div&gt; 好啦，大功告成！]]></content>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[添加一个萌物]]></title>
    <url>%2F2017%2F12%2F08%2F%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E8%90%8C%E7%89%A9%2F</url>
    <content type="text"><![CDATA[首先进入作者的GitHub，看看使用方法。链接：hexo-helper-live2d 1.安装1npm install --save hexo-helper-live2d 2.配置找到hexo根目录下的_config.yml文件在最后加上12345678910111213141516# Live2D## https://github.com/EYHN/hexo-helper-live2dlive2d: model: z16 # 模型名称 默认值: z16 width: 150 # 宽度 默认值: 150 height: 300 # 高度 默认值: 300 scaling: 1 # 分辨率缩放倍率 默认值: 2 opacityDefault: 0.7 # 初始的透明度 默认值: 0.7 opacityHover: 1 # 鼠标悬浮时的透明度 默认值: 1 mobileShow: true # 是否在移动设备上显示 默认值: true mobileScaling: 0.5 # 移动设备缩放倍率 默认值: 0.5 position: right # 模型左右侧放置位置 默认值: right horizontalOffset: 0 # 元素的水平偏移 默认值: 0 verticalOffset: -20 # 元素的底部偏移 默认值: -20 id: live2dcanvas # 元素的id 默认值: live2dcanvas deviceJsSource: local # current-device 脚本的来源 默认值: local 这段代码也可以直接从作者的链接上找到，上面有详细的参数介绍。重点是修改model: z16的值，我用的是hijiki这个灰色小猫的模型。 3.生效最后在\Hexo\themes\next\layout\_layout.swig文件中&lt;/body&gt;的上方加上这行代码1&#123;&#123; live2d() &#125;&#125; 最后，就如你在我的博客左下角所看到的那只有动画效果的灰色小猫咯。]]></content>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码块的测试]]></title>
    <url>%2F2017%2F12%2F07%2F%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[捣鼓了半天，发现代码高亮一直是黑白状态。没有颜色的变化。1234567891011def get_id_detail(id): &quot;&quot;&quot;根据歌单id获取歌单详细信息&quot;&quot;&quot; global headers print(&apos;fetching&apos;, id) url = &apos;http://music.163.com/api/playlist/detail?id=&#123;&#125;&amp;updateTime=-1&apos;.format(id) req = requests.get(url, headers=headers) detail = req.json() # print(detail) print(&apos;mongo&apos;, id) col_playlists.update(&#123;&apos;id&apos;: id&#125;, &#123;&apos;$set&apos;: detail[&apos;result&apos;]&#125;, upsert=True) print(&apos;done&apos;, id) 原来只要在’’’的开头加上你所用的语言名称就可以了！如&#39;&#39;&#39;pytho &#39;&#39;&#39; 效果如下：1234567891011def get_id_detail(id): """根据歌单id获取歌单详细信息""" global headers print('fetching', id) url = 'http://music.163.com/api/playlist/detail?id=&#123;&#125;&amp;updateTime=-1'.format(id) req = requests.get(url, headers=headers) detail = req.json() # print(detail) print('mongo', id) col_playlists.update(&#123;'id': id&#125;, &#123;'$set': detail['result']&#125;, upsert=True) print('done', id)]]></content>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <url>%2F2017%2F12%2F05%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[折腾了两天，看着crossin老师的教程，终于通过hexo+GitHub的方式把这个属于自己Blog弄出来了。总结一下学到的东西吧~ 学会了git的用法，创建了自己的GitHub Pages。 学会了hexo的用法，hexo更新命令： 1hexo g -d 学会了配置hexo主题，主题中的头像的修改，一些简介的修改，一些链接的设置等。]]></content>
  </entry>
</search>
